import { stringFormat, tryParseFloat, tryParseInt, parseToLocalDate } from './utils.js';
import { stringResources } from './stringResources.js';
import { ParameterTypes } from './enums.js';

var ParameterValidators = function() {
  var validators = {};
  function validateParameter(parameter, value, validatorFunc, compareFunc) {
    var values = [].concat(value).map(function(value1) {
      return checkAvailableValues(parameter, validatorFunc(value1), compareFunc);
    });
    if (parameter.multivalue) {
      if (value == null || value.length == 0) {
        if (parameter.allowNull) {
          return value;
        }
        throw stringResources.invalidParameter;
      }
      return values;
    }
    return values[0];
  }
  function isNull(parameter, value) {
    return parameter.allowNull && -1 != [null, "", void 0].indexOf(value);
  }
  function checkAvailableValues(parameter, value, compareFunc) {
    if (parameter.availableValues) {
      var found = Array.from(parameter.availableValues).some(function(av) {
        return compareFunc(value, av.value);
      });
      if (!found) {
        if (parameter.allowNull && !value) {
          return value;
        }
        throw stringResources.invalidParameter;
      }
    }
    return value;
  }
  validators[ParameterTypes.STRING] = {
    validate: function(parameter, value) {
      return validateParameter(
        parameter,
        value,
        function(value2) {
          if (!value2) {
            if (parameter.allowNull) {
              return null;
            }
            if (parameter.allowBlank) {
              return "";
            }
            throw stringResources.parameterIsEmpty;
          }
          return value2;
        },
        function(s1, s2) {
          return s1 == s2;
        }
      );
    }
  };
  validators[ParameterTypes.FLOAT] = {
    validate: function(parameter, value) {
      return validateParameter(
        parameter,
        value,
        function(value2) {
          var num = tryParseFloat(value2);
          if (isNaN(num)) {
            if (isNull(parameter, value2)) {
              return null;
            }
            throw stringResources.parameterIsEmpty;
          }
          return num;
        },
        function(f1, f2) {
          return tryParseFloat(f1) == tryParseFloat(f2);
        }
      );
    }
  };
  validators[ParameterTypes.INTEGER] = {
    validate: function(parameter, value) {
      return validateParameter(
        parameter,
        value,
        function(value2) {
          var num = tryParseInt(value2);
          if (isNaN(num)) {
            if (isNull(parameter, value2)) {
              return null;
            }
            throw stringResources.parameterIsEmpty;
          }
          return num;
        },
        function(n1, n2) {
          return tryParseInt(n1) == tryParseFloat(n2);
        }
      );
    }
  };
  validators[ParameterTypes.DATETIME] = {
    validate: function(parameter, value) {
      return validateParameter(
        parameter,
        value,
        function(value2) {
          if (parameter.allowNull && (value2 === null || value2 === "" || value2 === void 0)) {
            return null;
          }
          if (!isNaN(Date.parse(value2))) {
            if (parameter.availableValues) {
              return value2;
            }
            return parseToLocalDate(value2);
          }
          throw stringResources.invalidDateTimeValue;
        },
        function(d1, d2) {
          d1 = parseToLocalDate(d1);
          d2 = parseToLocalDate(d2);
          return d1.getTime() == d2.getTime();
        }
      );
    }
  };
  validators[ParameterTypes.BOOLEAN] = {
    validate: function(parameter, value) {
      return validateParameter(
        parameter,
        value,
        function(value2) {
          if (-1 != ["true", "false"].indexOf(String(value2).toLowerCase())) {
            return Boolean(value2);
          }
          if (isNull(parameter, value2)) {
            return null;
          }
          throw stringResources.parameterIsEmpty;
        },
        function(b1, b2) {
          return Boolean(b1) == Boolean(b2);
        }
      );
    }
  };
  return {
    validate: function(parameter, value) {
      var v = validators[parameter.type];
      if (!v) {
        throw stringFormat(stringResources.cannotValidateType, parameter);
      }
      return v.validate(parameter, value);
    }
  };
}();

export { ParameterValidators };
